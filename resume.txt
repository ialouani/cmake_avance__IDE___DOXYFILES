EXO1: 
fait depuis compile.sh && scp -R ialouani@(putty__<!!!):$(path)>.-stdout-() ./
 
EXO2:

rq: cmake-gui (graphic tool for cmake using)=>voir apres.

rq2:
********************
DEMANDEES AVEC cmake via ../CMakeLists.txt:
#compile la biblio ainsi que le programme example.c.
#gcc example.o -llibhash avec libhash.so ((la biblio de hash.c)).
#FAIT AVEC: gcc -fPIC -c hash.c puis gcc -shared -o llibhash.so hash.o.(gcc -c example (tout avant<()+__++.//))
#ou: ar rcs libhash.a hash.o(sans fPIC pour:: gcc -c hash.c MIEUX!!!&²²) => gcc libhash.a example.o avec gcc -c example.c
#avant(pas tout avant(au niveau de la deuxieme etape)).
********************

rq3:(pour un travail 'automatique'-pas perte de temps__+>>()())
****************************************************
INSTALLATION de cmake:
wget de l'archive depuis l'url 
tar -xvf(extraction en details des fichiers) puis cd dedans (en un unique folder)
./configure 
make
make install (qui suit make pour mettre les choses en place depuis configure .sh (sudo si erreur)).
=>2.8.11 (. . 3 nn) bonne!
(sudo apt purge cmake-qt-gui pour enlever la version collante de cmake_gui d'avant(3.16.3(pas bon du tout avec nos recents developpements(<<()#--____)/.///
=>=>cmake-gui!
sudo apt purge cmake-qt-gui (pour 3.16.3)
puis duso apt update && cd ~/cmake-2.8.11(deja via wget && tar -xzf(++) puis cd(..&²))
puis:: >>>
./configure --qt-gui
make -j5
bin/cmake-gui
mais tout avant: sudo apt-get build-dep cmake-qt-gui avant le wget ou l'acces a la precedente
meme si erreur apres: ./CONFIGURE --qt-gui le 3.16.3 fonctionne correctement::>>>
BROWNSE(attachements) source files: repository
// // binary build type file: ./(avant)build(deja cree avant(procedure cmake classique preliminaire)) 
puis configure puis generate 
1-configure<=>make(via contenance .PHONY)
2-generate<=>executer les executables generes.(voir les 3(atelier --makefile()))
****************************************************



=>reponse first part::>>>
cmake_minimun_required(VERSION 2.8.11)
project(HELLO)
add_library(hash_static STATIC hash.c)
target_include_directories(hash_static PUBLIC ${CMKAE_CURRENT_SOURCE_DIR})
add_executable(example1 example.c)
target_link_libraries(example1 LINK_PUBLIC hash_static)
puis cmake .. dans build ( a linterieur)
puis make (via .PHONY fait tout)
puis ./example1 ou ./example_dynamic ou les deux (;).

EXO3:
organisation des sources::
commande tres importante: add_subdirectory(path) indique qu'il faut charger le cmake trouve dans le $(path)|less.
1-hash; contient les fichiers de la biblio:: hash.c && hash.h
2->demo; contient example.c 
DANS CHACUN UN CMakeLists.txt et dans chaque sous repertoir evidemment.
**cmake-gui .. refere a cmake-gui tout court (pas de plus(~++)).**
>
add_subdirectory ajoute dans le folder exec. hello && demo (hello refere a hash principale target via project(HELLO))
creation donc de copie demo/hash dans le folder concerne(build2).
Puis dans chaque sous-repertoir pas sous_sous__repertOIR :::
on ajoute un cmake:(*.txt#~~)
//dans hello:
//dans demo:
cmake-gui .. puis make depuis demo fait le travail ou cmake .. puis execution depuis interieur demo fait tout.
un PLUS a prendre en compte:
la commande:
>>:
  	link_directories(${CMAKE_BINARY_DIR}/hash)
 pour potentiellement(''/////) prevenir les erreurs de recherche de libraires 
 la on specifie vraiment ou on va retrouver les libraries dans le repository/hash --copy ce qui est le cas (build2/hash apres un cmake .. depuis build2).
 FIN_EXO3.
Pas necessaire comme:
CMAKE_SOURCE_DIR/hash pour retenir hash.h dans la copie apres sub_directory
comme ce dernier qui indique que le linkage se recherche dans les cmake binaries cad. Ceux crees au debut fichiers compiles pour la BIBLIO/hash car le cmake demarre depuis ../copy quu refere a hash.
Eq. A dire que la recherche se fera dans les fichiers generes cad. Folder principale build2/hash ou on trouvera apres les librairies en question.
La variable LINK_PUBLIC ET PUBLIC dans les versions recentes tiennent compte de 
Cmake.. puis make entrainera lajout de demo et hash brut avant le make et le make fera le necessaire cad. Rapatrier les bonnes choses dans lesbons repertoirs.
Cad: build2/hash et build2/demo (travail de make genereation depuis ceux la)
Pour bien comprendre: make va faire depuis add subdirectory lajout de fonctionnalitees elementaires respectant le contrat de build2 (rapatriement) 
Cest pour cela que cmake.. fait une copie et make se contente dexecuter depuis la copie(cmd prec.) Lajout des executables dans les BONS ENDROITS.
CMAKE-GUI PUIS PATH SOURCES PUIS (BUILD2) CONFIGURE PUIS GENERATE EQ. A CMAKE .. seulement (CMAKEINSTALLPREFIX USR/LOCAL + CMAKE BUILD TYPE (TDS SUIVANTS)) DOU vient le probleme..
Si on fait seulement cmake.. puis  <{2} :::  cd demo puis make ca va generer tout contrairement a tout ceci depuis hash car linkage+ordre.
Les versions font en sorte que cmake-gui se comporte differemment selon nos besoins.
Fin remarqueS.
-----------------------------------------


Ide:(sm+/--/)
***********************************************************************EXO4:qtcreator:
Exo4:
->debut::
